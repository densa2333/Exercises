# 05-树9_Huffman_Codes

## Description

In 1953, David A. Huffman published his paper "A Method for the Construction of Minimum-Redundancy Codes", and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string "aaaxuaxz", we can observe that the frequencies of the characters 'a', 'x', 'u' and 'z' are 4, 2, 1 and 1, respectively. We may either encode the symbols as {'a'=0, 'x'=10, 'u'=110, 'z'=111}, or in another way as {'a'=1, 'x'=01, 'u'=001, 'z'=000}, both compress the string into 14 bits. Another set of code can be given as {'a'=0, 'x'=11, 'u'=100, 'z'=101}, but {'a'=0, 'x'=01, 'u'=011, 'z'=001} is NOT correct since "aaaxuaxz" and "aazuaxax" can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.



## Input Specification

Each input file contains one test case. For each case, the first line gives an integer *N* (2 ≤ *N* ≤ 63), then followed by a line that contains all the *N* distinct characters and their frequencies in the following format:

```
c[1] f[1] c[2] f[2] ... c[N] f[N]
```

where `c[i]` is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}, and `f[i]` is the frequency of `c[i]` and is an integer no more than 1000. The next line gives a positive integer *M* (≤1000), then followed by *M* student submissions. Each student submission consists of *N* lines, each in the format:

```
c[i] code[i]
```

where `c[i]` is the `i`-th character and `code[i]` is an non-empty string of no more than 63 '0's and '1's.



## Output Specification

For each test case, print in each line either "Yes" if the student's submission is correct, or "No" if not.

Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.



## Sample Input

```
7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11

```



## Sample Output

```
Yes
Yes
No
No

```



## Solution

题意理解：

- Huffman 编码不唯一（左右子树交换）
- 最优编玛不一定通过 Huffman 编码得到（不是通过最小值合并构造）

Huffman Codes 的特点：

1. 最优编玛 —— 总长度（WPL）最小
2. 无歧义解码 —— 前缀码：数据仅存于叶结点
3. 没有度为 1 的结点 —— 满足 1、2 则必然有 3

（注意：满足 2、 3 不一定有 1）

- 核心算法：
  - 计算最优编玛长度：
    - 根据建造的 HuffmanTree 递归求解 WPL
  - 对每位学生的提交检查：
    - 长度是否正确
    - 建树的过程中检查是否满足前缀码要求
- 难点：
  - 堆中元素是 HuffmanTree 的结点而不是指针，堆中操作的是结点而不是指针！
  - 是否熟练掌握堆的操作集

```C
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#define MINDATA -1000
#define ERROR NULL

typedef struct TreeNode *HuffmanTree;
typedef struct TreeNode {
    int Weight;
    HuffmanTree Left, Right;
} TreeNode;

typedef TreeNode ElementType;
typedef struct Heap *MinHeap;
struct Heap {
    ElementType *Data;
    int Size;
    int Capacity;
};

MinHeap CreateHeap(int);
MinHeap BuildMinHeap(int);
HuffmanTree DeleteMin(MinHeap);
bool Insert(MinHeap, HuffmanTree);
bool IsFull(MinHeap);
bool IsEmpty(MinHeap);
void freeTree(HuffmanTree);
HuffmanTree CreateTreeNode(int, int);

HuffmanTree Huffman(MinHeap);
int WPL(HuffmanTree, int);
void Submit(int, int);

int f[1001];

int main(void)
{
    int i, j, n, m, Codelen;
    
    scanf("%d", &n);
    getchar();
    MinHeap H = BuildMinHeap(n);
    HuffmanTree T = Huffman(H);
    Codelen = WPL(T, 0);

    scanf("%d", &m);
    getchar();
    for (i = 0; i < m; i++)
        Submit(n, Codelen);

    return 0;
}

MinHeap CreateHeap(int MaxSize)
{
    MinHeap H = malloc(sizeof(struct Heap));
    H->Data = malloc((MaxSize + 1) * sizeof(ElementType));
    H->Size = 0;
    H->Capacity = MaxSize;
    H->Data[0].Weight = MINDATA;
    H->Data[0].Left = H->Data[0].Right = NULL;
    return H;
}

MinHeap BuildMinHeap(int n)
{
    int i;
    HuffmanTree node;
    MinHeap H = CreateHeap(n);
    for (i = 0; i < n; i++) {
        getchar();
        getchar();
        scanf("%d", &f[i]);
        getchar();
        node = malloc(sizeof(struct TreeNode));
        node->Weight = f[i];
        node->Left = node->Right = NULL;
        Insert(H, node);
    }
    free(node);
    return H;
}

HuffmanTree DeleteMin(MinHeap H)
{
    int Parent, Child;
    ElementType tmp;
    HuffmanTree MinItem = malloc(sizeof(struct TreeNode));
    if (IsEmpty(H)) {
        printf("MinHeap is empty\n");
        return ERROR;
    }
    *MinItem = H->Data[1];
    tmp = H->Data[H->Size--];
    for (Parent = 1; Parent * 2 <= H->Size; Parent = Child) {
        Child = Parent * 2;
        if (Child != H->Size && H->Data[Child].Weight > H->Data[Child + 1].Weight)
            Child++;
        if (tmp.Weight > H->Data[Child].Weight)
            H->Data[Parent] = H->Data[Child];
        else
            break;
    }
    H->Data[Parent] = tmp;
    return MinItem;
}

bool Insert(MinHeap H, HuffmanTree T)
{
    int i;
    if (IsFull(H)) {
        printf("MinHeap is full\n");
        return false;
    }
    for (i = ++H->Size; H->Data[i / 2].Weight > T->Weight; i /= 2)
        H->Data[i] = H->Data[i / 2];
    H->Data[i] = *T;
    return true;
}

bool IsFull(MinHeap H)
{
    return (H->Size == H->Capacity);
}

bool IsEmpty(MinHeap H)
{
    return (H->Size == 0);
}

void freeTree(HuffmanTree T)
{
    if (T) {
        freeTree(T->Left);
        freeTree(T->Right);
        free(T);
    } else
        free(T);
}

HuffmanTree Huffman(MinHeap H)
{
    int i;
    HuffmanTree T;
    for (i = 1; i < H->Capacity; i++) {
        T = malloc(sizeof(struct TreeNode));
        T->Left = DeleteMin(H);
        T->Right = DeleteMin(H);
        T->Weight = T->Left->Weight + T->Right->Weight;
        Insert(H, T);
    }
    T = DeleteMin(H);
    return T;
}

int WPL(HuffmanTree T, int Depth)
{
    if (!T->Left && !T->Right)
        return (Depth * T->Weight);
    else
        return (WPL(T->Left, Depth + 1) + WPL(T->Right, Depth + 1));
}

HuffmanTree CreateTreeNode(int a, int b)
{
    HuffmanTree T = malloc(sizeof(struct TreeNode));
    if (a == b) T->Weight = 0;
    else T->Weight = 1;
    T->Left = T->Right = NULL;
    return T;
}

void Submit(int n, int Codelen)
{
    bool flag = true;
    int i, j, len, wpl;
    char code[64][1001];
    HuffmanTree T = NULL, root = CreateTreeNode(1, 2);

    for (i = 0; i < n; i++) {
        gets(code[i]);
    }

    wpl = 0;
    for (i = 0; i < n; i++) {
        len = strlen(code[i]) - 2;
        if (len > n - 1) {
            flag = false;
        }
        wpl += len * f[i];
    }
    if (wpl != Codelen) {
        flag = false;
    }
    
    for (i = 0; i < n && flag; i++) {
        len = strlen(code[i]);
        T = root;
        for (j = 2; j < len && flag; j++) {
            if (code[i][j] == '0') {
                if (!T->Left) {
                    T->Left = CreateTreeNode(j, len - 1);
                } else if (!T->Left->Weight) flag = false;
                T = T->Left;
            }
            if (code[i][j] == '1') {
                if (!T->Right) {
                    T->Right = CreateTreeNode(j, len - 1);
                } else if (!T->Right->Weight) flag = false;
                T = T->Right;
            }
            if (j == len - 1 && (T->Left || T->Right)) flag = false;
        }
    }

    if (flag) printf("Yes\n");
    else printf("No\n");
    freeTree(T);
    return;
}
```

